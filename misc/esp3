--// Services
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")

--// Local Player & Camera
local lplayer = Players.LocalPlayer
local Cam = Workspace.CurrentCamera

--// Get the main ESP table from getgenv()
local ESP = getgenv().ESP

--// Helper Functions
local function isTeammate(character)
    -- A more direct and efficient way to check for the teammate label.
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    return hrp and hrp:FindFirstChild("TeammateLabel")
end

local function getWeaponName(player)
    -- More efficient weapon name extraction using a single pattern match.
    if not Workspace:FindFirstChild("ViewModels") then return "none" end
    for _, viewModel in pairs(Workspace.ViewModels:GetChildren()) do
        local ownerName, weaponName = viewModel.Name:match("^(.-)%s*-%s*(.+)$")
        if ownerName and ownerName == player.Name then
            return weaponName
        end
    end
    return "none"
end

--// Main ESP Logic
local PlayerESPData = {}
local MainRenderConnection = nil
local RotationAngle, LastTick = -45, tick()

-- A single ScreenGui to hold all ESP elements
local ESPHolder = Instance.new("ScreenGui", CoreGui)
ESPHolder.Name = "ESPHolder"
ESPHolder.DisplayOrder = 999
ESPHolder.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Weapon icon assets
local Weapon_Icons = {
    ["Wooden Bow"] = "http://www.roblox.com/asset/?id=17677465400",
    ["Crossbow"] = "http://www.roblox.com/asset/?id=17677473017",
    ["Salvaged SMG"] = "http://www.roblox.com/asset/?id=17677463033",
    ["Salvaged AK47"] = "http://www.roblox.com/asset/?id=17677455113",
    ["Salvaged AK74u"] = "http://www.roblox.com/asset/?id=17677442346",
    ["Salvaged M14"] = "http://www.roblox.com/asset/?id=17677444642",
    ["Salvaged Python"] = "http://www.roblox.com/asset/?id=17677451737",
    ["Military PKM"] = "http://www.roblox.com/asset/?id=17677449448",
    ["Military M4A1"] = "http://www.roblox.com/asset/?id=17677479536",
    ["Bruno's M4A1"] = "http://www.roblox.com/asset/?id=17677471185",
    ["Military Barrett"] = "http://www.roblox.com/asset/?id=17677482998",
    ["Salvaged Skorpion"] = "http://www.roblox.com/asset/?id=17677459658",
    ["Salvaged Pump Action"] = "http://www.roblox.com/asset/?id=17677457186",
    ["Military AA12"] = "http://www.roblox.com/asset/?id=17677475227",
    ["Salvaged Break Action"] = "http://www.roblox.com/asset/?id=17677468751",
    ["Salvaged Pipe Rifle"] = "http://www.roblox.com/asset/?id=17677468751",
    ["Salvaged P250"] = "http://www.roblox.com/asset/?id=17677447257",
    ["Nail Gun"] = "http://www.roblox.com/asset/?id=17677484756"
}

--// Core Functions
local Functions = {}
do
    function Functions:Create(Class, Properties)
        local _Instance = Instance.new(Class)
        for Property, Value in pairs(Properties) do
            _Instance[Property] = Value
        end
        return _Instance
    end

    function Functions:FadeOutOnDist(element, distance)
        -- Calculates transparency based on distance from the player.
        local maxDist = getgenv().ESP.MaxDistance
        local transparency = math.clamp(1 - (distance / maxDist), 0, 1)
        
        if element:IsA("TextLabel") then
            element.TextTransparency = 1 - transparency
        elseif element:IsA("ImageLabel") then
            element.ImageTransparency = 1 - transparency
        elseif element:IsA("UIStroke") or element:IsA("UIGradient") then
            element.Transparency = NumberSequence.new(1 - transparency)
        elseif element:IsA("Frame") then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Highlight") then
            element.FillTransparency = 1 - transparency
            element.OutlineTransparency = 1 - transparency
        end
    end

    function Functions:CleanupPlayer(plr)
        if PlayerESPData[plr] then
            if PlayerESPData[plr].Elements then
                for _, element in pairs(PlayerESPData[plr].Elements) do
                    if element and element.Parent then
                        element:Destroy()
                    end
                end
            end
            PlayerESPData[plr] = nil
        end
    end

    function Functions:CleanupAll()
        if MainRenderConnection then
            MainRenderConnection:Disconnect()
            MainRenderConnection = nil
        end
        for plr, _ in pairs(PlayerESPData) do
            Functions:CleanupPlayer(plr)
        end
        if ESPHolder and ESPHolder.Parent then
            ESPHolder:Destroy()
        end
    end
end

--// ESP Creation and Management
local function CreatePlayerESP(plr)
    -- Clean up any previous data for this player to prevent duplicates.
    Functions:CleanupPlayer(plr)

    -- Create all UI elements upfront and store them. They are invisible by default.
    local Name = Functions:Create("TextLabel", {Parent = ESPHolder, ZIndex = 4, Position = UDim2.new(0.5, 0, 0, -11), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.new(1, 1, 1), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, RichText = true, Visible = false})
    local Distance = Functions:Create("TextLabel", {Parent = ESPHolder, ZIndex = 4, Position = UDim2.new(0.5, 0, 0, 11), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.new(1, 1, 1), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, RichText = true, Visible = false})
    local Weapon = Functions:Create("TextLabel", {Parent = ESPHolder, ZIndex = 4, Position = UDim2.new(0.5, 0, 0, 31), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.new(1, 1, 1), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, RichText = true, Visible = false})
    local Box = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 2, BackgroundColor3 = Color3.new(0, 0, 0), BackgroundTransparency = 0.75, BorderSizePixel = 0, Visible = false})
    local Gradient1 = Functions:Create("UIGradient", {Parent = Box, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)}})
    local Outline = Functions:Create("UIStroke", {Parent = Box, Transparency = 0, Color = Color3.new(1, 1, 1), LineJoinMode = Enum.LineJoinMode.Miter})
    local Gradient2 = Functions:Create("UIGradient", {Parent = Outline, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)}})
    local Healthbar = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 0, Visible = false})
    local BehindHealthbar = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 2, BackgroundColor3 = Color3.new(0, 0, 0), BackgroundTransparency = 0.2, Visible = false})
    local HealthbarGradient = Functions:Create("UIGradient", {Parent = Healthbar, Rotation = -90, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Healthbar.GradientRGB1), ColorSequenceKeypoint.new(0.5, ESP.Drawing.Healthbar.GradientRGB2), ColorSequenceKeypoint.new(1, ESP.Drawing.Healthbar.GradientRGB3)}})
    local HealthText = Functions:Create("TextLabel", {Parent = ESPHolder, ZIndex = 4, Position = UDim2.new(0.5, 0, 0, 31), Size = UDim2.new(0, 100, 0, 20), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, TextColor3 = Color3.new(1, 1, 1), Font = Enum.Font.Code, TextSize = ESP.FontSize, TextStrokeTransparency = 0, Visible = false})
    local Chams = Functions:Create("Highlight", {Parent = ESPHolder, FillTransparency = 1, OutlineTransparency = 0, OutlineColor = Color3.fromRGB(119, 120, 255), DepthMode = "AlwaysOnTop", Enabled = false})
    local WeaponIcon = Functions:Create("ImageLabel", {Parent = ESPHolder, ZIndex = 4, BackgroundTransparency = 1, Size = UDim2.new(0, 40, 0, 40), Visible = false})
    local Gradient3 = Functions:Create("UIGradient", {Parent = WeaponIcon, Rotation = -90, Color = ColorSequence.new{ColorSequenceKeypoint.new(0, ESP.Drawing.Weapons.GradientRGB1), ColorSequenceKeypoint.new(1, ESP.Drawing.Weapons.GradientRGB2)}})
    local LeftTop = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local LeftSide = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local RightTop = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local RightSide = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local BottomSide = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local BottomDown = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local BottomRightSide = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    local BottomRightDown = Functions:Create("Frame", {Parent = ESPHolder, ZIndex = 3, BackgroundColor3 = ESP.Drawing.Boxes.Corner.RGB, Visible = false})
    
    -- Store all elements for easy access and cleanup.
    PlayerESPData[plr] = {
        Elements = {Name, Distance, Weapon, Box, Healthbar, BehindHealthbar, HealthText, Chams, WeaponIcon, LeftTop, LeftSide, RightTop, RightSide, BottomSide, BottomDown, BottomRightSide, BottomRightDown},
        Name = Name, Distance = Distance, Weapon = Weapon, Box = Box, Gradient1 = Gradient1, Outline = Outline, Gradient2 = Gradient2, Healthbar = Healthbar, BehindHealthbar = BehindHealthbar,
        HealthbarGradient = HealthbarGradient, HealthText = HealthText, Chams = Chams, WeaponIcon = WeaponIcon, Gradient3 = Gradient3, LeftTop = LeftTop, LeftSide = LeftSide, RightTop = RightTop,
        RightSide = RightSide, BottomSide = BottomSide, BottomDown = BottomDown, BottomRightSide = BottomRightSide, BottomRightDown = BottomRightDown
    }
end

--[[
THE FIX: This is the new, robust main render loop.
It checks all conditions every frame for every player. This stateless approach ensures
that toggling `ESP.Enabled` on or off works instantly and reliably.
]]
local function MainRenderLoop()
    local currentESP = getgenv().ESP -- Get fresh settings every frame

    for plr, data in pairs(PlayerESPData) do
        -- Helper function to hide all ESP elements for the current player
        local function HidePlayerESP()
            if data and data.Elements then
                for _, element in pairs(data.Elements) do
                    if element and element.Parent then
                        if element:IsA("Highlight") then
                            element.Enabled = false
                        else
                            element.Visible = false
                        end
                    end
                end
            end
        end

        -- A series of checks. If any fail, hide the ESP for this player and skip to the next one.
        local character = plr.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local hrp = character and character:FindFirstChild("HumanoidRootPart")

        -- MASTER CHECK: Is the ESP globally enabled and is the player/character valid?
        if not currentESP.Enabled or not plr or not plr.Parent or not data or not character or not humanoid or not hrp or humanoid.Health <= 0 then
            HidePlayerESP()
            continue
        end

        -- TEAM CHECK: Are we ignoring teammates?
        if plr == lplayer or (currentESP.TeamCheck and isTeammate(character)) then
            HidePlayerESP()
            continue
        end

        -- ONSCREEN & DISTANCE CHECK: Is the player in view and within range?
        local pos, onScreen = Cam:WorldToScreenPoint(hrp.Position)
        local dist = (Cam.CFrame.Position - hrp.Position).Magnitude
        
        if not onScreen or dist > currentESP.MaxDistance then
            HidePlayerESP()
            continue
        end

        -- If all checks passed, we proceed to draw the ESP.
        local w, h = 100000 / dist, 120000 / dist -- Box size based on distance

        -- FADE EFFECT
        if currentESP.FadeOut.OnDistance then
            for _, element in pairs(data.Elements) do
                Functions:FadeOutOnDist(element, dist)
            end
        end

        -- CHAMS
        if currentESP.Drawing.Chams.Enabled then
            data.Chams.Adornee = character
            data.Chams.Enabled = true
            data.Chams.FillColor = currentESP.Drawing.Chams.FillRGB
            data.Chams.OutlineColor = currentESP.Drawing.Chams.OutlineRGB
            if currentESP.Drawing.Chams.Thermal then
                local breathe_effect = math.abs(math.sin(tick() * 2))
                data.Chams.FillTransparency = 1 - ((1 - currentESP.Drawing.Chams.Fill_Transparency) * breathe_effect)
                data.Chams.OutlineTransparency = 1 - ((1 - currentESP.Drawing.Chams.Outline_Transparency) * breathe_effect)
            else
                data.Chams.FillTransparency = currentESP.Drawing.Chams.Fill_Transparency
                data.Chams.OutlineTransparency = currentESP.Drawing.Chams.Outline_Transparency
            end
            data.Chams.DepthMode = currentESP.Drawing.Chams.VisibleCheck and "Occluded" or "AlwaysOnTop"
        else
            data.Chams.Enabled = false
        end

        -- BOXES (CORNER)
        if currentESP.Drawing.Boxes.Corner.Enabled then
            local cornerColor = currentESP.Drawing.Boxes.Corner.RGB
            data.LeftTop.BackgroundColor3, data.LeftSide.BackgroundColor3, data.RightTop.BackgroundColor3, data.RightSide.BackgroundColor3, data.BottomSide.BackgroundColor3, data.BottomDown.BackgroundColor3, data.BottomRightSide.BackgroundColor3, data.BottomRightDown.BackgroundColor3 = cornerColor, cornerColor, cornerColor, cornerColor, cornerColor, cornerColor, cornerColor, cornerColor
            data.LeftTop.Visible, data.LeftSide.Visible, data.RightTop.Visible, data.RightSide.Visible, data.BottomSide.Visible, data.BottomDown.Visible, data.BottomRightSide.Visible, data.BottomRightDown.Visible = true, true, true, true, true, true, true, true
            data.LeftTop.Position, data.LeftTop.Size = UDim2.fromOffset(pos.X - w / 2, pos.Y - h / 2), UDim2.fromOffset(w / 5, 1)
            data.LeftSide.Position, data.LeftSide.Size = UDim2.fromOffset(pos.X - w / 2, pos.Y - h / 2), UDim2.fromOffset(1, h / 5)
            data.BottomSide.Position, data.BottomSide.Size, data.BottomSide.AnchorPoint = UDim2.fromOffset(pos.X - w / 2, pos.Y + h / 2), UDim2.fromOffset(1, h / 5), Vector2.new(0, 1)
            data.BottomDown.Position, data.BottomDown.Size, data.BottomDown.AnchorPoint = UDim2.fromOffset(pos.X - w / 2, pos.Y + h / 2), UDim2.fromOffset(w / 5, 1), Vector2.new(0, 1)
            data.RightTop.Position, data.RightTop.Size, data.RightTop.AnchorPoint = UDim2.fromOffset(pos.X + w / 2, pos.Y - h / 2), UDim2.fromOffset(w / 5, 1), Vector2.new(1, 0)
            data.RightSide.Position, data.RightSide.Size, data.RightSide.AnchorPoint = UDim2.fromOffset(pos.X + w / 2, pos.Y - h / 2), UDim2.fromOffset(1, h / 5), Vector2.new(1, 0)
            data.BottomRightSide.Position, data.BottomRightSide.Size, data.BottomRightSide.AnchorPoint = UDim2.fromOffset(pos.X + w / 2, pos.Y + h / 2), UDim2.fromOffset(1, h / 5), Vector2.new(1, 1)
            data.BottomRightDown.Position, data.BottomRightDown.Size, data.BottomRightDown.AnchorPoint = UDim2.fromOffset(pos.X + w / 2, pos.Y + h / 2), UDim2.fromOffset(w / 5, 1), Vector2.new(1, 1)
        else
            data.LeftTop.Visible, data.LeftSide.Visible, data.BottomSide.Visible, data.BottomDown.Visible, data.RightTop.Visible, data.RightSide.Visible, data.BottomRightSide.Visible, data.BottomRightDown.Visible = false, false, false, false, false, false, false, false
        end
        
        -- BOXES (FULL)
        if currentESP.Drawing.Boxes.Full.Enabled then
            data.Box.Position, data.Box.Size, data.Box.Visible = UDim2.fromOffset(pos.X - w / 2, pos.Y - h / 2), UDim2.fromOffset(w, h), true
            data.Gradient1.Enabled, data.Gradient2.Enabled = currentESP.Drawing.Boxes.GradientFill, currentESP.Drawing.Boxes.Gradient
            data.Gradient1.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, currentESP.Drawing.Boxes.GradientFillRGB1), ColorSequenceKeypoint.new(1, currentESP.Drawing.Boxes.GradientFillRGB2)}
            data.Gradient2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, currentESP.Drawing.Boxes.GradientRGB1), ColorSequenceKeypoint.new(1, currentESP.Drawing.Boxes.GradientRGB2)}
            data.Box.BackgroundTransparency = currentESP.Drawing.Boxes.Filled.Enabled and currentESP.Drawing.Boxes.Filled.Transparency or 1
            if currentESP.Drawing.Boxes.Animate then
                RotationAngle = RotationAngle + (tick() - LastTick) * currentESP.Drawing.Boxes.RotationSpeed * 10
                data.Gradient1.Rotation, data.Gradient2.Rotation = RotationAngle, RotationAngle
            else
                data.Gradient1.Rotation, data.Gradient2.Rotation = -45, -45
            end
        else
            data.Box.Visible = false
        end

        -- HEALTHBAR
        if currentESP.Drawing.Healthbar.Enabled then
            local health = humanoid.Health / humanoid.MaxHealth
            data.Healthbar.Visible, data.BehindHealthbar.Visible = true, true
            data.Healthbar.Position = UDim2.fromOffset(pos.X - w / 2 - 6, pos.Y - h / 2 + h * (1 - health))
            data.Healthbar.Size = UDim2.fromOffset(currentESP.Drawing.Healthbar.Width, h * health)
            data.BehindHealthbar.Position, data.BehindHealthbar.Size = UDim2.fromOffset(pos.X - w / 2 - 6, pos.Y - h / 2), UDim2.fromOffset(currentESP.Drawing.Healthbar.Width, h)
            data.HealthbarGradient.Enabled = currentESP.Drawing.Healthbar.Gradient
            data.HealthbarGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, currentESP.Drawing.Healthbar.GradientRGB1), ColorSequenceKeypoint.new(0.5, currentESP.Drawing.Healthbar.GradientRGB2), ColorSequenceKeypoint.new(1, currentESP.Drawing.Healthbar.GradientRGB3)}
            if currentESP.Drawing.Healthbar.HealthText then
                local healthPercentage = math.floor(health * 100)
                data.HealthText.Position = UDim2.fromOffset(pos.X - w / 2 - 16, pos.Y + h / 2)
                data.HealthText.AnchorPoint = Vector2.new(1, 1)
                data.HealthText.Text = tostring(healthPercentage) .. "%"
                data.HealthText.Visible = health < 1
                data.HealthText.TextColor3 = currentESP.Drawing.Healthbar.Lerp and Color3.fromHSV(health * 0.33, 1, 1) or currentESP.Drawing.Healthbar.HealthTextRGB
            else
                data.HealthText.Visible = false
            end
        else
            data.Healthbar.Visible, data.BehindHealthbar.Visible, data.HealthText.Visible = false, false, false
        end

        -- NAME
        if currentESP.Drawing.Names.Enabled then
            data.Name.Visible, data.Name.TextSize = true, currentESP.FontSize
            local friendColor = string.format("rgb(%d, %d, %d)", currentESP.Options.FriendcheckRGB.R * 255, currentESP.Options.FriendcheckRGB.G * 255, currentESP.Options.FriendcheckRGB.B * 255)
            local enemyColor = "rgb(255, 80, 80)"
            local prefix = (currentESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId)) and string.format('(<font color="%s">F</font>) ', friendColor) or string.format('(<font color="%s">E</font>) ', enemyColor)
            data.Name.Text = prefix .. plr.Name
            data.Name.Position = UDim2.fromOffset(pos.X, pos.Y - h / 2 - 9)
        else
            data.Name.Visible = false
        end

        -- DISTANCE
        if currentESP.Drawing.Distances.Enabled then
            data.Distance.TextSize = currentESP.FontSize
            if currentESP.Drawing.Distances.Position == "Bottom" then
                data.Distance.Position = UDim2.fromOffset(pos.X, pos.Y + h / 2 + 7)
                data.Distance.Text = string.format("%.0f M", dist)
                data.Distance.Visible = true
            elseif currentESP.Drawing.Distances.Position == "Text" then
                data.Distance.Visible = false
                if currentESP.Drawing.Names.Enabled then -- Append to name if enabled
                    data.Name.Text = data.Name.Text .. string.format(' [%.0f M]', dist)
                end
            end
        else
            data.Distance.Visible = false
        end
        
        -- WEAPON
        local weaponName = getWeaponName(plr)
        local weaponTextY = pos.Y + h / 2 + (currentESP.Drawing.Distances.Enabled and currentESP.Drawing.Distances.Position == "Bottom" and 18 or 8)
        
        if currentESP.Drawing.Weapons.Enabled then
            data.Weapon.Text, data.Weapon.TextSize, data.Weapon.Visible = weaponName, currentESP.FontSize, true
            data.Weapon.Position = UDim2.fromOffset(pos.X, weaponTextY)
            data.Gradient3.Enabled = currentESP.Drawing.Weapons.Gradient
            data.Gradient3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, currentESP.Drawing.Weapons.GradientRGB1), ColorSequenceKeypoint.new(1, currentESP.Drawing.Weapons.GradientRGB2)}
            if currentESP.Drawing.Weapons.Icon and Weapon_Icons[weaponName] then
                data.WeaponIcon.Image, data.WeaponIcon.Visible = Weapon_Icons[weaponName], true
                data.WeaponIcon.Position = UDim2.fromOffset(pos.X - data.WeaponIcon.AbsoluteSize.X / 2, weaponTextY + 12)
            else
                data.WeaponIcon.Visible = false
            end
        else
            data.Weapon.Visible, data.WeaponIcon.Visible = false, false
        end
    end
    LastTick = tick()
end

--// Initialization and Connections
do
    -- Initial setup for all players currently in the game.
    for _, player in pairs(Players:GetPlayers()) do
        CreatePlayerESP(player)
    end

    -- Connect events to handle players joining and leaving.
    Players.PlayerAdded:Connect(CreatePlayerESP)
    Players.PlayerRemoving:Connect(Functions.CleanupPlayer)

    -- Start the main render loop.
    MainRenderConnection = RunService.RenderStepped:Connect(MainRenderLoop)

    -- Expose cleanup function to the environment.
    getgenv().CleanupESP = function()
        Functions:CleanupAll()
    end
end
